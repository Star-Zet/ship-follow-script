{"slots":{"0":{"name":"core","type":{"events":[],"methods":[]}},"1":{"name":"hover","type":{"events":[],"methods":[]}},"2":{"name":"telemetr","type":{"events":[],"methods":[]}},"3":{"name":"atmofueltank_2","type":{"events":[],"methods":[]}},"4":{"name":"atmofueltank_3","type":{"events":[],"methods":[]}},"5":{"name":"spacefueltank_1","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-5":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"system.showHelper(false)\nunit.hideWidget()\n-- category panel display helpers\n_autoconf = {}\n_autoconf.panels = {}\n_autoconf.panels_size = 0\n_autoconf.displayCategoryPanel = function(elements, size, title, type, widgetPerData)\n    widgetPerData = widgetPerData or false -- default to one widget for all data\n    if size > 0 then\n        local panel = system.createWidgetPanel(title)\n        local widget\n        if not widgetPerData then\n            widget = system.createWidget(panel, type)\n        end\n        for i = 1, size do\n            if widgetPerData then\n                widget = system.createWidget(panel, type)\n            end\n            system.addDataToWidget(elements[i].getWidgetDataId(), widget)\n        end\n        _autoconf.panels_size = _autoconf.panels_size + 1\n        _autoconf.panels[_autoconf.panels_size] = panel\n    end\nend\n_autoconf.hideCategoryPanels = function()\n    for i=1,_autoconf.panels_size do\n        system.destroyWidgetPanel(_autoconf.panels[i])\n    end\nend\n-- Proxy array to access auto-plugged slots programmatically\n\natmofueltank = {}\natmofueltank_size = 0\n\nspacefueltank = {}\nspacefueltank_size = 0\n\nrocketfueltank = {}\nrocketfueltank_size = 0\n\nweapon = {}\nweapon_size = 0\n\nradar = {}\nradar_size = 0\n-- End of auto-generated code\npitchInput = 0\nrollInput = 0\nyawInput = 0\nbrakeInput = 0\n\nNav = Navigator.new(system, core, unit)\nNav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})\nNav.axisCommandManager:setTargetGroundAltitude(4)\n-- Parenting widget\n--parentingPanelId = system.createWidgetPanel(\"Docking\")\n--parentingWidgetId = system.createWidget(parentingPanelId,\"parenting\")\n--system.addDataToWidget(unit.getWidgetDataId(),parentingWidgetId)\n\n-- Combat stress widget\n--coreCombatStressPanelId = system.createWidgetPanel(\"Core combat stress\")\n--coreCombatStressgWidgetId = system.createWidget(coreCombatStressPanelId,\"core_stress\")\n--system.addDataToWidget(core.getWidgetDataId(),coreCombatStressgWidgetId)\n\n-- element widgets\n-- For now we have to alternate between PVP and non-PVP widgets to have them on the same side.\n--_autoconf.displayCategoryPanel(weapon, weapon_size, \"Weapons\", \"weapon\", true)\n--core.showWidget()\n--_autoconf.displayCategoryPanel(radar, radar_size, \"Periscope\", \"periscope\")\nplaceRadar = false\nif atmofueltank_size > 0 then\n    _autoconf.displayCategoryPanel(atmofueltank, atmofueltank_size, \"Atmo Fuel\", \"fuel_container\")\n    if placeRadar then\n        _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n        placeRadar = false\n    end\nend\nif spacefueltank_size > 0 then\n    _autoconf.displayCategoryPanel(spacefueltank, spacefueltank_size, \"Space Fuel\", \"fuel_container\")\n    if placeRadar then\n        _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n        placeRadar = false\n    end\nend\n--_autoconf.displayCategoryPanel(rocketfueltank, rocketfueltank_size, \"Rocket Fuel\", \"fuel_container\")\nif placeRadar then -- We either have only rockets or no fuel tanks at all, uncommon for usual vessels\n    _autoconf.displayCategoryPanel(radar, radar_size, \"Radar\", \"radar\")\n    placeRadar = false\nend\nif antigrav ~= nil then antigrav.showWidget() end\nif warpdrive ~= nil then warpdrive.showWidget() end\nif gyro ~= nil then gyro.showWidget() end\nif shield ~= nil then shield.showWidget() end\n\n-- freeze the player in he is remote controlling the construct\nif unit.isRemoteControlled() == 1 then\n    player.freeze(0)\nend\n\n-- landing gear\n-- make sure every gears are synchonized with the first\ngearExtended = (unit.isAnyLandingGearDeployed() == 1) -- make sure it's a lua boolean\nif gearExtended then\n    unit.deployLandingGears()\nelse\n    unit.retractLandingGears()\nend\n","filter":{"args":[],"signature":"onStart()","slotKey":"-1"},"key":"0"},{"code":"_autoconf.hideCategoryPanels()\nif antigrav ~= nil then antigrav.hideWidget() end\nif warpdrive ~= nil then warpdrive.hideWidget() end\nif gyro ~= nil then gyro.hideWidget() end\ncore.hideWidget()\nunit.switchOffHeadlights()\n","filter":{"args":[],"signature":"onStop()","slotKey":"-1"},"key":"1"},{"code":"system.showScreen(true)\nunit.setTimer(\"t\",0.05)\n\npercX = 1\ndistance = 0\ntargetAlt = 4 --export: Target ground altitude\ndistChange = 0\npercXInput = 0\ndistWas =0\nmanualControl = false\n\nvelocityForwardDeg = 0\ncurrentRollDeg = 0\ncurrentPitchDeg = 0\ncurrentYawDeg = 0\nvertDeg = 0\nconstructVelocity = vec3()\nvelocityForwardDeg = 0\nlenBSelf = 0\ntargetLen = construct.getSize()[1]/4 -- 1/4 is actualy 1/2 of core size in meters\ntargetLenNeed = -1 --export: Target distance from the ship center to the player. (-1 means default dist 1/2 of core size)\nif targetLenNeed ~= -1 then\n    targetLen = math.max(targetLenNeed, 0)\nend\ntargetLen = targetLen + targetAlt\nvelDotForw = 0\nneedThrottle = 0\ntargetPitch = false\nsummHover = 0\nvelocityDownDeg = 0\nvelDotDown = 0\nconstructForward = vec3()\nconstructUp = vec3()\nsec2 = 0\nmetr2 = 0\n\nfunction getVertDeg(worldVertical,constructUp)\n    local vertDeg = math.acos(utils.clamp(constructUp:dot(worldVertical), -1, 1)) * constants.rad2deg\n    return vertDeg\nend\n\n-- devs function from \\Dual Universe\\data\\lua\\Helpers.lua\nfunction getRoll(gravityDirection, forward, right)\n    local horizontalRight = gravityDirection:cross(forward):normalize_inplace()\n    local roll = math.acos(utils.clamp(horizontalRight:dot(right), -1, 1)) * constants.rad2deg\n    if horizontalRight:cross(right):dot(forward) < 0 then roll = -roll end\n    return roll\nend\n\nfunction toStr(a)\n    if a[1] then\n        return string.format(\"(%0.3f,%0.3f,%0.3f)\", a[1] or 0, a[2] or 0, a[3] or 0)\n    end\n    return string.format(\"(%0.3f,%0.3f,%0.3f)\", a.x or 0, a.y or 0, a.z or 0)\nend\nsec = 0\nmetr = 0\ncontent = \n    [[<div style=\"position:absolute; left:15vh; top:90vh; display: block; width:4vw; height:6vh; text-align:center ; font-size:2vh;\n    border: 0.5vh solid ;border-color: teal\"> alt+1<br> Exit</div>]]\nfunction seeParams()\n    system.setScreen(content)\nend\n\nfunction seeParams2()\n    content2 = content..\n    [[<div style=\"position:absolute; left:5vh; top:20vh; display: block; width:90vw; height:90vh; text-align:left; font-size:2vh;\">]]\n    .. \"R \" .. utils.round(currentRollDeg,0.0001) \n    .. \"<br>P \" .. utils.round(currentPitchDeg,0.0001) \n    .. \"<br>Y \" .. utils.round(currentYawDeg,0.0001)\n    .. \"<br>V \" .. utils.round(vertDeg,0.0001)\n    .. \"<br><br>distance \" .. utils.round(distance,0.0001)\n    .. \"<br>percXInput \" .. percXInput\n    .. \"<br>percX \" .. percX\n    .. \"<br><br>distChange \" .. distChange\n    .. \"<br>targetAlt \" .. targetAlt\n    .. \"<br>targetLen \" .. targetLen\n    .. \"<br><br>playerPos \" .. toStr(vec3(player.getWorldPosition()))\n    .. \"<br>lenBSelf \" .. lenBSelf\n    .. \"<br>constructVelocity \" .. toStr(constructVelocity)\n    .. \"<br>constructVelocityLen \" .. constructVelocity:len()\n    .. \"<br><br>velocityForwardDeg \" .. velocityForwardDeg\n    .. \"<br>velDotForwLen \" .. velDotForw\n    .. \"<br>getMass \" .. construct.getMass()\n    .. \"<br>getMaxBrake \" .. construct.getMaxBrake()/9.81\n    .. \"<br>sec \" .. sec\n    .. \"<br>metr \" .. metr\n    .. \"<br>getWorldVertical \" .. toStr(vec3(core.getWorldVertical()))\n    .. \"<br>getWorldVertical \" .. -vec3(player.getWorldUp()):len()\n    .. \"<br>summHover \" .. summHover \n    .. \"<br>velocityDownDeg \" .. velocityDownDeg\n    .. \"<br>velDotDown \" .. velDotDown\n    .. \"<br>sec2 \" .. sec2\n    .. \"<br>metr2 \" .. metr2\n    .. [[</div>]]\n    system.setScreen(content2)\nend\n\n\n","filter":{"args":[],"signature":"onStart()","slotKey":"-1"},"key":"2"},{"code":"seeParams()\n--seeParams2()\nif telemetr or hover then\n    if telemetr then\n        distance = telemetr.raycast()[\"distance\"]\n        else\n        if hover then\n            distance = hover.getDistance()\n        end\n    end\n    else\n    assert(false,\"need connect telemetr or one of hovers for ground distance\")\nend\n\nif math.abs(targetAlt - distance) > 0.001 then\n    distChange = distWas - distance\n    percXInput = (targetAlt - distance)*0.55 + distChange*3.5\n    distWas = distance\n    percX = 1 + percXInput\n    if targetAlt < 0 and distance < 0.05 then\n        percX = 0\n    end\nend\n\nvelDotForw = vec3(constructVelocity:dot(constructForward)):len()\nif math.abs(velocityForwardDeg) > 90 then\n    velDotForw = -velDotForw\nend\nvelDotDown = vec3(constructVelocity:dot(-constructUp)):len()\nif math.abs(velocityDownDeg) > 90 then\n    velDotDown = -velDotDown\nend\n\n\nthrottleNow = utils.round(unit.getThrottle())\nlocal needThrottleSet = 0\nif throttleNow < needThrottle then\n    needThrottleSet = 1\n    else if throttleNow > needThrottle then\n        needThrottleSet = -1\n    end\nend\nif not manualControl then\n    Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal,needThrottleSet)\nend\n\nsec = (vec3(velDotForw):len()*construct.getMass()) / (construct.getMaxBrake()/9.81)\nmetr = velDotForw*sec\n\naxisCRefDirection = vec3(construct.getOrientationUp())\nlocal maxKPAlongAxis = construct.getMaxThrustAlongAxis('thrust analog vertical', {axisCRefDirection:unpack()})\nlocal maxAtmoForceForward = maxKPAlongAxis[1]\nlocal maxSpaceForceForward = maxKPAlongAxis[3]\nsummHover = maxAtmoForceForward + maxSpaceForceForward\n\nsec2 = (vec3(velDotDown):len()*construct.getMass()) / (summHover/9.81)\nmetr2 = velDotDown*sec2","filter":{"args":[{"value":"t"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"3"},{"code":"Nav:update()","filter":{"args":[],"signature":"onUpdate()","slotKey":"-4"},"key":"4"},{"code":"gearExtended = not gearExtended\nif gearExtended then\n    unit.deployLandingGears()\nelse\n    unit.retractLandingGears()\nend\n","filter":{"args":[{"value":"gear"}],"signature":"onActionStart(gear)","slotKey":"-4"},"key":"5"},{"code":"if unit.isAnyHeadlightSwitchedOn() == 1 then\n    unit.switchOffHeadlights()\nelse\n    unit.switchOnHeadlights()\nend\n","filter":{"args":[{"value":"light"}],"signature":"onActionStart(light)","slotKey":"-4"},"key":"6"},{"code":"pitchInput = pitchInput - 1","filter":{"args":[{"value":"forward"}],"signature":"onActionStart(forward)","slotKey":"-4"},"key":"7"},{"code":"pitchInput = pitchInput + 1","filter":{"args":[{"value":"forward"}],"signature":"onActionStop(forward)","slotKey":"-4"},"key":"8"},{"code":"pitchInput = pitchInput + 1","filter":{"args":[{"value":"backward"}],"signature":"onActionStart(backward)","slotKey":"-4"},"key":"9"},{"code":"pitchInput = pitchInput - 1","filter":{"args":[{"value":"backward"}],"signature":"onActionStop(backward)","slotKey":"-4"},"key":"10"},{"code":"rollInput = rollInput - 1","filter":{"args":[{"value":"left"}],"signature":"onActionStart(left)","slotKey":"-4"},"key":"11"},{"code":"rollInput = rollInput + 1","filter":{"args":[{"value":"left"}],"signature":"onActionStop(left)","slotKey":"-4"},"key":"12"},{"code":"rollInput = rollInput + 1","filter":{"args":[{"value":"right"}],"signature":"onActionStart(right)","slotKey":"-4"},"key":"13"},{"code":"rollInput = rollInput - 1","filter":{"args":[{"value":"right"}],"signature":"onActionStop(right)","slotKey":"-4"},"key":"14"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, 1.0)","filter":{"args":[{"value":"straferight"}],"signature":"onActionStart(straferight)","slotKey":"-4"},"key":"15"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, -1.0)","filter":{"args":[{"value":"straferight"}],"signature":"onActionStop(straferight)","slotKey":"-4"},"key":"16"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.lateral, -1.0)","filter":{"args":[{"value":"strafeleft"}],"signature":"onActionStart(strafeleft)","slotKey":"-4"},"key":"17"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.lateral, 1.0)","filter":{"args":[{"value":"strafeleft"}],"signature":"onActionStop(strafeleft)","slotKey":"-4"},"key":"18"},{"code":"Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()\nNav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, 1.0)\n","filter":{"args":[{"value":"up"}],"signature":"onActionStart(up)","slotKey":"-4"},"key":"19"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, -1.0)\nNav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)\n","filter":{"args":[{"value":"up"}],"signature":"onActionStop(up)","slotKey":"-4"},"key":"20"},{"code":"Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()\nNav.axisCommandManager:updateCommandFromActionStart(axisCommandId.vertical, -1.0)\n","filter":{"args":[{"value":"down"}],"signature":"onActionStart(down)","slotKey":"-4"},"key":"21"},{"code":"Nav.axisCommandManager:updateCommandFromActionStop(axisCommandId.vertical, 1.0)\nNav.axisCommandManager:activateGroundEngineAltitudeStabilization(currentGroundAltitudeStabilization)\n","filter":{"args":[{"value":"down"}],"signature":"onActionStop(down)","slotKey":"-4"},"key":"22"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(1.0)","filter":{"args":[{"value":"groundaltitudeup"}],"signature":"onActionStart(groundaltitudeup)","slotKey":"-4"},"key":"23"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(1.0)","filter":{"args":[{"value":"groundaltitudeup"}],"signature":"onActionLoop(groundaltitudeup)","slotKey":"-4"},"key":"24"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionStart(-1.0)","filter":{"args":[{"value":"groundaltitudedown"}],"signature":"onActionStart(groundaltitudedown)","slotKey":"-4"},"key":"25"},{"code":"Nav.axisCommandManager:updateTargetGroundAltitudeFromActionLoop(-1.0)","filter":{"args":[{"value":"groundaltitudedown"}],"signature":"onActionLoop(groundaltitudedown)","slotKey":"-4"},"key":"26"},{"code":"yawInput = yawInput - 1","filter":{"args":[{"value":"yawright"}],"signature":"onActionStart(yawright)","slotKey":"-4"},"key":"27"},{"code":"yawInput = yawInput + 1","filter":{"args":[{"value":"yawright"}],"signature":"onActionStop(yawright)","slotKey":"-4"},"key":"28"},{"code":"yawInput = yawInput + 1","filter":{"args":[{"value":"yawleft"}],"signature":"onActionStart(yawleft)","slotKey":"-4"},"key":"29"},{"code":"yawInput = yawInput - 1","filter":{"args":[{"value":"yawleft"}],"signature":"onActionStop(yawleft)","slotKey":"-4"},"key":"30"},{"code":"brakeInput = brakeInput + 1\nlocal longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)\n    if (math.abs(targetSpeed) > constants.epsilon) then\n        Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, - utils.sign(targetSpeed))\n    end\nend\n","filter":{"args":[{"value":"brake"}],"signature":"onActionStart(brake)","slotKey":"-4"},"key":"31"},{"code":"brakeInput = brakeInput - 1","filter":{"args":[{"value":"brake"}],"signature":"onActionStop(brake)","slotKey":"-4"},"key":"32"},{"code":"local longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local targetSpeed = Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal)\n    if (math.abs(targetSpeed) > constants.epsilon) then\n        Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, - utils.sign(targetSpeed))\n    end\nend\n","filter":{"args":[{"value":"brake"}],"signature":"onActionLoop(brake)","slotKey":"-4"},"key":"33"},{"code":"Nav:toggleBoosters()","filter":{"args":[{"value":"booster"}],"signature":"onActionStart(booster)","slotKey":"-4"},"key":"34"},{"code":"Nav.axisCommandManager:resetCommand(axisCommandId.longitudinal)","filter":{"args":[{"value":"stopengines"}],"signature":"onActionStart(stopengines)","slotKey":"-4"},"key":"35"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, 5.0)","filter":{"args":[{"value":"speedup"}],"signature":"onActionStart(speedup)","slotKey":"-4"},"key":"36"},{"code":"Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, 1.0)","filter":{"args":[{"value":"speedup"}],"signature":"onActionLoop(speedup)","slotKey":"-4"},"key":"37"},{"code":"Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal, -5.0)","filter":{"args":[{"value":"speeddown"}],"signature":"onActionStart(speeddown)","slotKey":"-4"},"key":"38"},{"code":"Nav.axisCommandManager:updateCommandFromActionLoop(axisCommandId.longitudinal, -1.0)","filter":{"args":[{"value":"speeddown"}],"signature":"onActionLoop(speeddown)","slotKey":"-4"},"key":"39"},{"code":"if antigrav ~= nil then antigrav.toggle() end","filter":{"args":[{"value":"antigravity"}],"signature":"onActionStart(antigravity)","slotKey":"-4"},"key":"40"},{"code":"-- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu\n\nlocal pitchSpeedFactor = 0.8 -- This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal yawSpeedFactor =  1 -- This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal rollSpeedFactor = 1.5 -- This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal brakeSpeedFactor = 3 -- When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01\nlocal brakeFlatFactor = 1 -- When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal autoRoll = true -- [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)\nlocal autoRollFactor = 2 -- [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01\n\nlocal turnAssist = true -- [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is\nlocal turnAssistFactor = 2 -- [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\n-- validate params\npitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)\nyawSpeedFactor = math.max(yawSpeedFactor, 0.01)\nrollSpeedFactor = math.max(rollSpeedFactor, 0.01)\ntorqueFactor = math.max(torqueFactor, 0.01)\nbrakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)\nbrakeFlatFactor = math.max(brakeFlatFactor, 0.01)\nautoRollFactor = math.max(autoRollFactor, 0.01)\nturnAssistFactor = math.max(turnAssistFactor, 0.01)\n\n-- final inputs\nlocal finalPitchInput = 0\nlocal finalRollInput = 0\nlocal finalYawInput = 0\nlocal finalBrakeInput = 0\n\nif manualControl then\n    finalPitchInput = pitchInput + system.getControlDeviceForwardInput()\n    finalRollInput = rollInput + system.getControlDeviceYawInput()\n    finalYawInput = yawInput - system.getControlDeviceLeftRightInput()\n    finalBrakeInput = brakeInput\nend\n\nlocal constructAngularVelocity = vec3(construct.getWorldAngularVelocity())\n-- Axis\nlocal worldVertical = vec3(core.getWorldVertical()) -- along gravity\nif unit.getAtmosphereDensity() <= 0.0 then\n    if worldVertical:len() < 0.01 then\n        if construct.getParrent() ~= 0 then\n            worldVertical = -vec3(construct.getParentWorldUp())\n            else\n            worldVertical = -vec3(player.getWorldUp())\n            targetPitch = true\n        end\n    end\nend\nconstructUp = vec3(construct.getWorldOrientationUp())\nconstructForward = vec3(construct.getWorldOrientationForward())\nconstructRight = vec3(construct.getWorldOrientationRight())\nconstructVelocity = vec3(construct.getWorldVelocity())\n\nif constructVelocity:len() < 0.1 then\n    velocityForwardDeg = 0\n    velocityDownDeg = 0\n    else\n    velocityForwardDeg = getRoll(constructVelocity, constructUp, constructRight)\n    velocityDownDeg = getVertDeg(constructVelocity,-constructUp)\nend\n\nlocal constructVelocityDir = vec3(construct.getWorldVelocity()):normalize()\ncurrentRollDeg = getRoll(worldVertical, constructForward, constructRight)\nlocal currentRollDegSign = utils.sign(currentRollDeg)\n\ncurrentPitchDeg = getRoll(worldVertical, constructRight, -constructForward)\n\ncSelf = vec3(construct.getWorldCenterOfMass())\ndestTo = player.getWorldPosition()\nvDestTo = vec3(vec3(destTo) - cSelf):normalize_inplace()\nlenBSelf = (vec3(destTo) - vec3(cSelf)):len()\nif targetPitch then\n    currentPitchDeg = getRoll(vDestTo, constructRight, -constructUp)\nend\nlocal currentRollDegAbs = math.abs(currentRollDeg)\nlocal currentPitchDegAbs = math.abs(currentPitchDeg)\nvertDeg = getVertDeg(worldVertical,-constructUp)\ncurrentYawDeg = getRoll(vDestTo, constructUp, constructRight)\nlocal currentYawDegAbs = math.abs(currentYawDeg)\nif lenBSelf < targetLen then\n    autoRoll = false\n    else\n    autoRoll = true\nend\nif vertDeg > 25 or currentYawDegAbs > 20 then\n    needThrottle = 0\n    finalBrakeInput = 1\n    \n    else\n    if lenBSelf < targetLen then\n        needThrottle = 0\n        finalBrakeInput = 1\n        \n        else\n        finalBrakeInput = 0\n        if math.abs(velocityForwardDeg) > 25 then\n            finalBrakeInput = 1\n            \n            else\n            needThrottle = 100\n            if lenBSelf < metr then\n                needThrottle = 0\n                finalBrakeInput = 1\n            end\n        end\n    end\nend\nif distance < metr2 or distance <= 0 and not targetPitch then --in case of a fall\n    finalBrakeInput = 1\n    --needThrottle = 0\n    percX = 10\nend\n\n-- Rotation\nlocal targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight\n                                + finalRollInput * rollSpeedFactor * constructForward\n                                + finalYawInput * yawSpeedFactor * constructUp\n\n-- In atmosphere?\n--if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then\nif true then\n    local autoRollRollThreshold = 0.1\n    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling\n    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then\n        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit\n        if (rollPID == nil) then\n            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range\n        end\n        rollPID:inject(targetRollDeg - currentRollDeg)\n        local autoRollInput = rollPID:get()\n\n        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward\n    end\n    \n    -- autoPitch\n    if autoRoll == true and currentPitchDegAbs > autoRollRollThreshold and finalPitchInput == 0 then\n        local targetPitchDeg = utils.clamp(0,currentPitchDegAbs-30, currentPitchDegAbs+30);  -- we go back to 0 within a certain limit\n        if (PitchPID == nil) then\n            PitchPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range\n        end\n        PitchPID:inject(targetPitchDeg - currentPitchDeg)\n        local autoPitchInput = PitchPID:get()\n\n        targetAngularVelocity = targetAngularVelocity + autoPitchInput * constructRight\n    end\n    \n    -- autoYaw\n    if autoRoll == true and currentYawDegAbs > autoRollRollThreshold and finalYawInput == 0 then\n        local targetYawDeg = utils.clamp(0,currentYawDegAbs-30, currentYawDegAbs+30);  -- we go back to 0 within a certain limit\n        if (YawPID == nil) then\n            YawPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range\n        end\n        YawPID:inject(targetYawDeg - currentYawDeg)\n        local autoYawInput = YawPID:get()\n\n        targetAngularVelocity = targetAngularVelocity + autoYawInput * constructUp\n    end\n    \n    local turnAssistRollThreshold = 20.0\n    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing\n    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then\n        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range\n        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range\n\n        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)\n        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180\n        local rollVerticalRatio = 0\n        if rescaleRollDegAbs < 90 then\n            rollVerticalRatio = rescaleRollDegAbs / 90\n        elseif rescaleRollDegAbs < 180 then\n            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90\n        end\n\n        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio\n\n        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)\n        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio\n\n        targetAngularVelocity = targetAngularVelocity\n                            + turnAssistPitchInput * constructRight\n                            + turnAssistYawInput * constructUp\n    end\nend\n\n-- Engine commands\nlocal keepCollinearity = 1 -- for easier reading\nlocal dontKeepCollinearity = 0 -- for easier reading\nlocal tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities\n\n-- Rotation\nlocal angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)\nlocal airAcceleration = vec3(construct.getWorldAirFrictionAngularAcceleration())\nangularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction\nNav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)\n\n-- Brakes\nlocal brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)\nNav:setEngineForceCommand('brake', brakeAcceleration)\n\n-- AutoNavigation regroups all the axis command by 'TargetSpeed'\nlocal autoNavigationEngineTags = ''\nlocal autoNavigationAcceleration = vec3()\nlocal autoNavigationUseBrake = false\n\n-- Longitudinal Translation\nlocal longitudinalEngineTags = 'thrust analog longitudinal'\nlocal longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byThrottle) then\n    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)\n    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)\nelseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration\n    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop\n        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking\n    then\n        autoNavigationUseBrake = true\n    end\n\nend\n\n-- Lateral Translation\nlocal lateralStrafeEngineTags = 'thrust analog lateral'\nlocal lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)\nif (lateralCommandType == axisCommandType.byThrottle) then\n    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)\n    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)\nelseif  (lateralCommandType == axisCommandType.byTargetSpeed) then\n    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration\nend\n\n-- Vertical Translation\nlocal verticalStrafeEngineTags = 'thrust analog vertical'\nlocal verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)\nif (verticalCommandType == axisCommandType.byThrottle) then\n    verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)\n    verticalStrafeAcceleration = verticalStrafeAcceleration * percX\n    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, 1, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)\n    vertAcceleration = verticalStrafeAcceleration\n    Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()\nelseif  (verticalCommandType == axisCommandType.byTargetSpeed) then\n    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration\nend\n-- Auto Navigation (Cruise Control)\nif (autoNavigationAcceleration:len() > constants.epsilon) then\n    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward\n    then\n        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'\n    end\n    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)\nend\n\n-- Rockets\nNav:setBoosterCommand('rocket_engine')\n\n","filter":{"args":[],"signature":"onFlush()","slotKey":"-4"},"key":"41"},{"code":"unit.exit()","filter":{"args":[{"value":"option1"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"42"}],"methods":[],"events":[]}
