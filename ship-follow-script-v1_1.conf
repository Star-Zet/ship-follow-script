{"slots":{"0":{"name":"slot1","type":{"events":[],"methods":[]}},"1":{"name":"slot2","type":{"events":[],"methods":[]}},"2":{"name":"slot3","type":{"events":[],"methods":[]}},"3":{"name":"slot4","type":{"events":[],"methods":[]}},"4":{"name":"slot5","type":{"events":[],"methods":[]}},"5":{"name":"slot6","type":{"events":[],"methods":[]}},"6":{"name":"slot7","type":{"events":[],"methods":[]}},"7":{"name":"slot8","type":{"events":[],"methods":[]}},"8":{"name":"slot9","type":{"events":[],"methods":[]}},"9":{"name":"slot10","type":{"events":[],"methods":[]}},"-1":{"name":"unit","type":{"events":[],"methods":[]}},"-3":{"name":"player","type":{"events":[],"methods":[]}},"-2":{"name":"construct","type":{"events":[],"methods":[]}},"-4":{"name":"system","type":{"events":[],"methods":[]}},"-5":{"name":"library","type":{"events":[],"methods":[]}}},"handlers":[{"code":"system.showHelper(false)\nunit.hideWidget()\npitchInput = 0\nrollInput = 0\nyawInput = 0\nbrakeInput = 0\n\nNav = Navigator.new(system, core, unit)\nNav.axisCommandManager:setupCustomTargetSpeedRanges(axisCommandId.longitudinal, {1000, 5000, 10000, 20000, 30000})\nNav.axisCommandManager:setTargetGroundAltitude(4)\nplayer.freeze(0)\n\nsystem.showScreen(true)\nunit.setTimer(\"t\",0.05)\n\ntelemetr = nil\ncore = nil\nfor slot_name, slot in pairs(unit) do\n    if type(slot) == \"table\"\n        and type(slot.export) == \"table\"\n        and slot.getClass\n    then\n        if slot.getClass():lower() == 'telemeterunit' then\n            telemetr = slot\n        end\n        if slot.getClass():lower():find(\"coreunit\") then\n            core = slot\n        end\n    end\nend\n\nexit = false\nif telemetr == nil then\n    system.print(\"No Telemeter Detected\"); exit = true\nend\nif core == nil then\n    system.print(\"No Core Detected\"); exit = true\nend\nif exit then\n    unit.exit()\nend\n\npercX = 1\ndistance = 0\ntargetAlt = 6 --export: Target ground altitude\ndistChange = 0\npercXInput = 0\ndistWas =0\nmanualControl = false\n\nvelocityForwardDeg = 0\ncurrentRollDeg = 0\ncurrentPitchDeg = 0\ncurrentYawDeg = 0\nvertDeg = 0\nconstructVelocity = vec3()\nvelocityForwardDeg = 0\nlenBSelf = 0\ntargetLen = construct.getSize()[1]/4 -- 1/4 is actualy 1/2 of core size in meters\ntargetLenNeed = -1 --export: Target distance from the ship center to the player. (-1 means default dist 1/2 of core size)\nif targetLenNeed ~= -1 then\n    targetLen = math.max(targetLenNeed, 0)\nend\ntargetLen = targetLen + targetAlt\nvelDotForw = 0\nneedThrottle = 0\ntargetPitch = false\nsummHover = 0\nvelocityDownDeg = 0\nvelDotDown = 0\nconstructForward = vec3()\nconstructUp = vec3()\nsec2 = 0\nmetr2 = 0\n\nfunction getVertDeg(worldVertical,constructUp)\n    local vertDeg = math.acos(utils.clamp(constructUp:dot(worldVertical), -1, 1)) * constants.rad2deg\n    return vertDeg\nend\n\n-- devs function from \\Dual Universe\\data\\lua\\Helpers.lua\nfunction getRoll(gravityDirection, forward, right)\n    local horizontalRight = gravityDirection:cross(forward):normalize_inplace()\n    local roll = math.acos(utils.clamp(horizontalRight:dot(right), -1, 1)) * constants.rad2deg\n    if horizontalRight:cross(right):dot(forward) < 0 then roll = -roll end\n    return roll\nend\n\nfunction toStr(a)\n    if a[1] then\n        return string.format(\"(%0.3f,%0.3f,%0.3f)\", a[1] or 0, a[2] or 0, a[3] or 0)\n    end\n    return string.format(\"(%0.3f,%0.3f,%0.3f)\", a.x or 0, a.y or 0, a.z or 0)\nend\nsec = 0\nmetr = 0\ncontent = \n    [[<div style=\"position:absolute; left:15vh; top:90vh; display: block; width:4vw; height:6vh; text-align:center ; font-size:2vh;\n    border: 0.5vh solid ;border-color: teal\"> alt+1<br> Exit</div>]]\nfunction seeParams()\n    system.setScreen(content)\nend\n\nfunction seeParams2()\n    content2 = content..\n    [[<div style=\"position:absolute; left:5vh; top:20vh; display: block; width:90vw; height:90vh; text-align:left; font-size:2vh;\">]]\n    .. \"R \" .. utils.round(currentRollDeg,0.0001) \n    .. \"<br>P \" .. utils.round(currentPitchDeg,0.0001) \n    .. \"<br>Y \" .. utils.round(currentYawDeg,0.0001)\n    .. \"<br>V \" .. utils.round(vertDeg,0.0001)\n    .. \"<br><br>distance \" .. utils.round(distance,0.0001)\n    .. \"<br>percXInput \" .. percXInput\n    .. \"<br>percX \" .. percX\n    .. \"<br><br>distChange \" .. distChange\n    .. \"<br>targetAlt \" .. targetAlt\n    .. \"<br>targetLen \" .. targetLen\n    .. \"<br><br>playerPos \" .. toStr(vec3(player.getWorldPosition()))\n    .. \"<br>lenBSelf \" .. lenBSelf\n    .. \"<br>constructVelocity \" .. toStr(constructVelocity)\n    .. \"<br>constructVelocityLen \" .. constructVelocity:len()\n    .. \"<br><br>velocityForwardDeg \" .. velocityForwardDeg\n    .. \"<br>velDotForwLen \" .. velDotForw\n    .. \"<br>getMass \" .. construct.getMass()\n    .. \"<br>getMaxBrake \" .. construct.getMaxBrake()/9.81\n    .. \"<br>sec \" .. sec\n    .. \"<br>metr \" .. metr\n    .. \"<br>getWorldVertical \" .. toStr(vec3(core.getWorldVertical()))\n    .. \"<br>getWorldVertical \" .. -vec3(player.getWorldUp()):len()\n    .. \"<br>summHover \" .. summHover \n    .. \"<br>velocityDownDeg \" .. velocityDownDeg\n    .. \"<br>velDotDown \" .. velDotDown\n    .. \"<br>sec2 \" .. sec2\n    .. \"<br>metr2 \" .. metr2\n    .. [[</div>]]\n    system.setScreen(content2)\nend\n\n\n\n","filter":{"args":[],"signature":"onStart()","slotKey":"-1"},"key":"0"},{"code":"seeParams()\n--seeParams2()\nif telemetr or hover then\n    if telemetr then\n        distance = telemetr.raycast()[\"distance\"]\n        else\n        if hover then\n            distance = hover.getDistance()\n        end\n    end\n    else\n    assert(false,\"need connect telemetr or one of hovers for ground distance\")\nend\n\nif math.abs(targetAlt - distance) > 0.001 then\n    distChange = distWas - distance\n    percXInput = (targetAlt - distance)*0.55 + distChange*3.5\n    distWas = distance\n    percX = 1 + percXInput\n    if targetAlt < 0 and distance < 0.05 then\n        percX = 0\n    end\nend\n\nvelDotForw = vec3(constructVelocity:dot(constructForward)):len()\nif math.abs(velocityForwardDeg) > 90 then\n    velDotForw = -velDotForw\nend\nvelDotDown = vec3(constructVelocity:dot(-constructUp)):len()\nif math.abs(velocityDownDeg) > 90 then\n    velDotDown = -velDotDown\nend\n\n\nthrottleNow = utils.round(unit.getThrottle())\nlocal needThrottleSet = 0\nif throttleNow < needThrottle then\n    needThrottleSet = 1\n    else if throttleNow > needThrottle then\n        needThrottleSet = -1\n    end\nend\nif not manualControl then\n    Nav.axisCommandManager:updateCommandFromActionStart(axisCommandId.longitudinal,needThrottleSet)\nend\n\nsec = (vec3(velDotForw):len()*construct.getMass()) / (construct.getMaxBrake()/9.81)\nmetr = velDotForw*sec\n\naxisCRefDirection = vec3(construct.getOrientationUp())\nlocal maxKPAlongAxis = construct.getMaxThrustAlongAxis('thrust analog vertical', {axisCRefDirection:unpack()})\nlocal maxAtmoForceForward = maxKPAlongAxis[1]\nlocal maxSpaceForceForward = maxKPAlongAxis[3]\nsummHover = maxAtmoForceForward + maxSpaceForceForward\n\nsec2 = (vec3(velDotDown):len()*construct.getMass()) / (summHover/9.81)\nmetr2 = velDotDown*sec2","filter":{"args":[{"value":"t"}],"signature":"onTimer(tag)","slotKey":"-1"},"key":"1"},{"code":"Nav:update()","filter":{"args":[],"signature":"onUpdate()","slotKey":"-4"},"key":"2"},{"code":"-- constants: use 'myvar = defaultValue --export: description' to expose the variable in context menu\n\nlocal pitchSpeedFactor = 0.8 -- This factor will increase/decrease the player input along the pitch axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal yawSpeedFactor =  1 -- This factor will increase/decrease the player input along the yaw axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\nlocal rollSpeedFactor = 1.5 -- This factor will increase/decrease the player input along the roll axis<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal brakeSpeedFactor = 3 -- When braking, this factor will increase the brake force by brakeSpeedFactor * velocity<br>Valid values: Superior or equal to 0.01\nlocal brakeFlatFactor = 1 -- When braking, this factor will increase the brake force by a flat brakeFlatFactor * velocity direction><br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal autoRoll = true -- [Only in atmosphere]<br>When the pilot stops rolling,  flight model will try to get back to horizontal (no roll)\nlocal autoRollFactor = 2 -- [Only in atmosphere]<br>When autoRoll is engaged, this factor will increase to strength of the roll back to 0<br>Valid values: Superior or equal to 0.01\n\nlocal turnAssist = true -- [Only in atmosphere]<br>When the pilot is rolling, the flight model will try to add yaw and pitch to make the construct turn better<br>The flight model will start by adding more yaw the more horizontal the construct is and more pitch the more vertical it is\nlocal turnAssistFactor = 2 -- [Only in atmosphere]<br>This factor will increase/decrease the turnAssist effect<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\nlocal torqueFactor = 2 -- Force factor applied to reach rotationSpeed<br>(higher value may be unstable)<br>Valid values: Superior or equal to 0.01\n\n-- validate params\npitchSpeedFactor = math.max(pitchSpeedFactor, 0.01)\nyawSpeedFactor = math.max(yawSpeedFactor, 0.01)\nrollSpeedFactor = math.max(rollSpeedFactor, 0.01)\ntorqueFactor = math.max(torqueFactor, 0.01)\nbrakeSpeedFactor = math.max(brakeSpeedFactor, 0.01)\nbrakeFlatFactor = math.max(brakeFlatFactor, 0.01)\nautoRollFactor = math.max(autoRollFactor, 0.01)\nturnAssistFactor = math.max(turnAssistFactor, 0.01)\n\n-- final inputs\nlocal finalPitchInput = 0\nlocal finalRollInput = 0\nlocal finalYawInput = 0\nlocal finalBrakeInput = 0\n\nif manualControl then\n    finalPitchInput = pitchInput + system.getControlDeviceForwardInput()\n    finalRollInput = rollInput + system.getControlDeviceYawInput()\n    finalYawInput = yawInput - system.getControlDeviceLeftRightInput()\n    finalBrakeInput = brakeInput\nend\n\nlocal constructAngularVelocity = vec3(construct.getWorldAngularVelocity())\n-- Axis\nlocal worldVertical = vec3(core.getWorldVertical()) -- along gravity\nif unit.getAtmosphereDensity() <= 0.0 then\n    if worldVertical:len() < 0.01 then\n        if construct.getParrent() ~= 0 then\n            worldVertical = -vec3(construct.getParentWorldUp())\n            else\n            worldVertical = -vec3(player.getWorldUp())\n            targetPitch = true\n        end\n    end\nend\nconstructUp = vec3(construct.getWorldOrientationUp())\nconstructForward = vec3(construct.getWorldOrientationForward())\nconstructRight = vec3(construct.getWorldOrientationRight())\nconstructVelocity = vec3(construct.getWorldVelocity())\n\nif constructVelocity:len() < 0.1 then\n    velocityForwardDeg = 0\n    velocityDownDeg = 0\n    else\n    velocityForwardDeg = getRoll(constructVelocity, constructUp, constructRight)\n    velocityDownDeg = getVertDeg(constructVelocity,-constructUp)\nend\n\nlocal constructVelocityDir = vec3(construct.getWorldVelocity()):normalize()\ncurrentRollDeg = getRoll(worldVertical, constructForward, constructRight)\nlocal currentRollDegSign = utils.sign(currentRollDeg)\n\ncurrentPitchDeg = getRoll(worldVertical, constructRight, -constructForward)\n\ncSelf = vec3(construct.getWorldCenterOfMass())\ndestTo = player.getWorldPosition()\nvDestTo = vec3(vec3(destTo) - cSelf):normalize_inplace()\nlenBSelf = (vec3(destTo) - vec3(cSelf)):len()\nif targetPitch then\n    currentPitchDeg = getRoll(vDestTo, constructRight, -constructUp)\nend\nlocal currentRollDegAbs = math.abs(currentRollDeg)\nlocal currentPitchDegAbs = math.abs(currentPitchDeg)\nvertDeg = getVertDeg(worldVertical,-constructUp)\ncurrentYawDeg = getRoll(vDestTo, constructUp, constructRight)\nlocal currentYawDegAbs = math.abs(currentYawDeg)\nif lenBSelf < targetLen then\n    autoRoll = false\n    else\n    autoRoll = true\nend\nif vertDeg > 25 or currentYawDegAbs > 20 then\n    needThrottle = 0\n    finalBrakeInput = 1\n    \n    else\n    if lenBSelf < targetLen then\n        needThrottle = 0\n        finalBrakeInput = 1\n        \n        else\n        finalBrakeInput = 0\n        if math.abs(velocityForwardDeg) > 25 then\n            finalBrakeInput = 1\n            \n            else\n            needThrottle = 100\n            if lenBSelf < metr then\n                needThrottle = 0\n                finalBrakeInput = 1\n            end\n        end\n    end\nend\nif distance < metr2 or distance <= 0 and not targetPitch then --in case of a fall\n    finalBrakeInput = 1\n    --needThrottle = 0\n    percX = 10\nend\n\n-- Rotation\nlocal targetAngularVelocity = finalPitchInput * pitchSpeedFactor * constructRight\n                                + finalRollInput * rollSpeedFactor * constructForward\n                                + finalYawInput * yawSpeedFactor * constructUp\n\n-- In atmosphere?\n--if worldVertical:len() > 0.01 and unit.getAtmosphereDensity() > 0.0 then\nif true then\n    local autoRollRollThreshold = 0.1\n    -- autoRoll on AND currentRollDeg is big enough AND player is not rolling\n    if autoRoll == true and currentRollDegAbs > autoRollRollThreshold and finalRollInput == 0 then\n        local targetRollDeg = utils.clamp(0,currentRollDegAbs-30, currentRollDegAbs+30);  -- we go back to 0 within a certain limit\n        if (rollPID == nil) then\n            rollPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range\n        end\n        rollPID:inject(targetRollDeg - currentRollDeg)\n        local autoRollInput = rollPID:get()\n\n        targetAngularVelocity = targetAngularVelocity + autoRollInput * constructForward\n    end\n    \n    -- autoPitch\n    if autoRoll == true and currentPitchDegAbs > autoRollRollThreshold and finalPitchInput == 0 then\n        local targetPitchDeg = utils.clamp(0,currentPitchDegAbs-30, currentPitchDegAbs+30);  -- we go back to 0 within a certain limit\n        if (PitchPID == nil) then\n            PitchPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range\n        end\n        PitchPID:inject(targetPitchDeg - currentPitchDeg)\n        local autoPitchInput = PitchPID:get()\n\n        targetAngularVelocity = targetAngularVelocity + autoPitchInput * constructRight\n    end\n    \n    -- autoYaw\n    if autoRoll == true and currentYawDegAbs > autoRollRollThreshold and finalYawInput == 0 then\n        local targetYawDeg = utils.clamp(0,currentYawDegAbs-30, currentYawDegAbs+30);  -- we go back to 0 within a certain limit\n        if (YawPID == nil) then\n            YawPID = pid.new(autoRollFactor * 0.01, 0, autoRollFactor * 0.1) -- magic number tweaked to have a default factor in the 1-10 range\n        end\n        YawPID:inject(targetYawDeg - currentYawDeg)\n        local autoYawInput = YawPID:get()\n\n        targetAngularVelocity = targetAngularVelocity + autoYawInput * constructUp\n    end\n    \n    local turnAssistRollThreshold = 20.0\n    -- turnAssist AND currentRollDeg is big enough AND player is not pitching or yawing\n    if turnAssist == true and currentRollDegAbs > turnAssistRollThreshold and finalPitchInput == 0 and finalYawInput == 0 then\n        local rollToPitchFactor = turnAssistFactor * 0.1 -- magic number tweaked to have a default factor in the 1-10 range\n        local rollToYawFactor = turnAssistFactor * 0.025 -- magic number tweaked to have a default factor in the 1-10 range\n\n        -- rescale (turnAssistRollThreshold -> 180) to (0 -> 180)\n        local rescaleRollDegAbs = ((currentRollDegAbs - turnAssistRollThreshold) / (180 - turnAssistRollThreshold)) * 180\n        local rollVerticalRatio = 0\n        if rescaleRollDegAbs < 90 then\n            rollVerticalRatio = rescaleRollDegAbs / 90\n        elseif rescaleRollDegAbs < 180 then\n            rollVerticalRatio = (180 - rescaleRollDegAbs) / 90\n        end\n\n        rollVerticalRatio = rollVerticalRatio * rollVerticalRatio\n\n        local turnAssistYawInput = - currentRollDegSign * rollToYawFactor * (1.0 - rollVerticalRatio)\n        local turnAssistPitchInput = rollToPitchFactor * rollVerticalRatio\n\n        targetAngularVelocity = targetAngularVelocity\n                            + turnAssistPitchInput * constructRight\n                            + turnAssistYawInput * constructUp\n    end\nend\n\n-- Engine commands\nlocal keepCollinearity = 1 -- for easier reading\nlocal dontKeepCollinearity = 0 -- for easier reading\nlocal tolerancePercentToSkipOtherPriorities = 1 -- if we are within this tolerance (in%), we don't go to the next priorities\n\n-- Rotation\nlocal angularAcceleration = torqueFactor * (targetAngularVelocity - constructAngularVelocity)\nlocal airAcceleration = vec3(construct.getWorldAirFrictionAngularAcceleration())\nangularAcceleration = angularAcceleration - airAcceleration -- Try to compensate air friction\nNav:setEngineTorqueCommand('torque', angularAcceleration, keepCollinearity, 'airfoil', '', '', tolerancePercentToSkipOtherPriorities)\n\n-- Brakes\nlocal brakeAcceleration = -finalBrakeInput * (brakeSpeedFactor * constructVelocity + brakeFlatFactor * constructVelocityDir)\nNav:setEngineForceCommand('brake', brakeAcceleration)\n\n-- AutoNavigation regroups all the axis command by 'TargetSpeed'\nlocal autoNavigationEngineTags = ''\nlocal autoNavigationAcceleration = vec3()\nlocal autoNavigationUseBrake = false\n\n-- Longitudinal Translation\nlocal longitudinalEngineTags = 'thrust analog longitudinal'\nlocal longitudinalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.longitudinal)\nif (longitudinalCommandType == axisCommandType.byThrottle) then\n    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(longitudinalEngineTags,axisCommandId.longitudinal)\n    Nav:setEngineForceCommand(longitudinalEngineTags, longitudinalAcceleration, keepCollinearity)\nelseif  (longitudinalCommandType == axisCommandType.byTargetSpeed) then\n    local longitudinalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.longitudinal)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. longitudinalEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + longitudinalAcceleration\n    if (Nav.axisCommandManager:getTargetSpeed(axisCommandId.longitudinal) == 0 or -- we want to stop\n        Nav.axisCommandManager:getCurrentToTargetDeltaSpeed(axisCommandId.longitudinal) < - Nav.axisCommandManager:getTargetSpeedCurrentStep(axisCommandId.longitudinal) * 0.5) -- if the longitudinal velocity would need some braking\n    then\n        autoNavigationUseBrake = true\n    end\n\nend\n\n-- Lateral Translation\nlocal lateralStrafeEngineTags = 'thrust analog lateral'\nlocal lateralCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.lateral)\nif (lateralCommandType == axisCommandType.byThrottle) then\n    local lateralStrafeAcceleration =  Nav.axisCommandManager:composeAxisAccelerationFromThrottle(lateralStrafeEngineTags,axisCommandId.lateral)\n    Nav:setEngineForceCommand(lateralStrafeEngineTags, lateralStrafeAcceleration, keepCollinearity)\nelseif  (lateralCommandType == axisCommandType.byTargetSpeed) then\n    local lateralAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.lateral)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. lateralStrafeEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + lateralAcceleration\nend\n\n-- Vertical Translation\nlocal verticalStrafeEngineTags = 'thrust analog vertical'\nlocal verticalCommandType = Nav.axisCommandManager:getAxisCommandType(axisCommandId.vertical)\nif (verticalCommandType == axisCommandType.byThrottle) then\n    verticalStrafeAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromThrottle(verticalStrafeEngineTags,axisCommandId.vertical)\n    verticalStrafeAcceleration = verticalStrafeAcceleration * percX\n    Nav:setEngineForceCommand(verticalStrafeEngineTags, verticalStrafeAcceleration, 1, 'airfoil', 'ground', '', tolerancePercentToSkipOtherPriorities)\n    vertAcceleration = verticalStrafeAcceleration\n    Nav.axisCommandManager:deactivateGroundEngineAltitudeStabilization()\nelseif  (verticalCommandType == axisCommandType.byTargetSpeed) then\n    local verticalAcceleration = Nav.axisCommandManager:composeAxisAccelerationFromTargetSpeed(axisCommandId.vertical)\n    autoNavigationEngineTags = autoNavigationEngineTags .. ' , ' .. verticalStrafeEngineTags\n    autoNavigationAcceleration = autoNavigationAcceleration + verticalAcceleration\nend\n-- Auto Navigation (Cruise Control)\nif (autoNavigationAcceleration:len() > constants.epsilon) then\n    if (brakeInput ~= 0 or autoNavigationUseBrake or math.abs(constructVelocityDir:dot(constructForward)) < 0.95)  -- if the velocity is not properly aligned with the forward\n    then\n        autoNavigationEngineTags = autoNavigationEngineTags .. ', brake'\n    end\n    Nav:setEngineForceCommand(autoNavigationEngineTags, autoNavigationAcceleration, dontKeepCollinearity, '', '', '', tolerancePercentToSkipOtherPriorities)\nend\n\n-- Rockets\nNav:setBoosterCommand('rocket_engine')\n\n\n","filter":{"args":[],"signature":"onFlush()","slotKey":"-4"},"key":"3"},{"code":"unit.exit()","filter":{"args":[{"value":"option1"}],"signature":"onActionStart(action)","slotKey":"-4"},"key":"4"}],"methods":[],"events":[]}
